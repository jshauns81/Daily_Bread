@using Daily_Bread.Data.Models
@using Daily_Bread.Services

<div class="routines-list">
    <div class="routines-header">
        @if (EnableReorder)
        {
            <span class="drag-header"></span>
        }
        <span>Routine</span>
        <span>Schedule</span>
        <span>Actions</span>
    </div>
    @foreach (var chore in RoutineChores)
    {
        var isBeingDragged = _draggedChore?.ChoreDefinitionId == chore.ChoreDefinitionId;
        var isDropTarget = _dropTargetChore?.ChoreDefinitionId == chore.ChoreDefinitionId && !isBeingDragged;
        
        <div class="routine-row @(isBeingDragged ? "dragging" : "") @(isDropTarget ? "drop-target" : "")" 
             @key="chore.ChoreDefinitionId"
             draggable="@(EnableReorder ? "true" : "false")"
             @ondragstart="() => HandleDragStart(chore)"
             @ondragend="HandleDragEnd"
             @ondragover="() => HandleDragOver(chore)"
             @ondragover:preventDefault="@EnableReorder"
             @ondrop="() => HandleDrop(chore)"
             @ondrop:preventDefault="@EnableReorder">
            @if (EnableReorder)
            {
                <div class="drag-handle-cell">
                    <span class="drag-handle" title="Drag to reorder">
                        <span class="bi bi-grip-vertical"></span>
                    </span>
                </div>
            }
            <div class="routine-info">
                <span class="routine-emoji">@(chore.Icon ?? "✨")</span>
                <span class="routine-name">@chore.ChoreName</span>
                @if (string.IsNullOrEmpty(SelectedUserId) && !string.IsNullOrEmpty(chore.AssignedUserName))
                {
                    <span class="routine-assignee">@chore.AssignedUserName</span>
                }
            </div>
            <div class="routine-schedule">
                <span class="schedule-badge">@chore.ScheduleDescription</span>
            </div>
            <div class="routine-actions">
                <button class="icon-btn edit" @onclick="() => OnEditChore.InvokeAsync(chore)" title="Edit">
                    <span class="bi bi-pencil"></span>
                </button>
            </div>
        </div>
    }
</div>

<div class="add-routine-footer">
    <button class="add-routine-btn" @onclick="() => OnAddRoutine.InvokeAsync()">
        <span class="bi bi-plus-lg"></span>
        <span>Add Routine</span>
    </button>
</div>

@code {
    [Parameter, EditorRequired] public List<ChorePlannerRow> RoutineChores { get; set; } = [];
    [Parameter] public string? SelectedUserId { get; set; }
    [Parameter] public EventCallback<ChorePlannerRow> OnEditChore { get; set; }
    [Parameter] public EventCallback OnAddRoutine { get; set; }
    
    /// <summary>
    /// Enable drag-and-drop reordering. When true, shows drag handles.
    /// </summary>
    [Parameter] public bool EnableReorder { get; set; } = true;
    
    /// <summary>
    /// Called when chores are reordered via drag-and-drop.
    /// Returns list of (ChoreId, NewSortOrder) tuples.
    /// </summary>
    [Parameter] public EventCallback<List<(int ChoreId, int SortOrder)>> OnReorder { get; set; }

    private ChorePlannerRow? _draggedChore;
    private ChorePlannerRow? _dropTargetChore;

    private void HandleDragStart(ChorePlannerRow chore)
    {
        if (!EnableReorder) return;
        _draggedChore = chore;
    }

    private void HandleDragEnd()
    {
        _draggedChore = null;
        _dropTargetChore = null;
    }

    private void HandleDragOver(ChorePlannerRow chore)
    {
        if (!EnableReorder || _draggedChore == null || _draggedChore.ChoreDefinitionId == chore.ChoreDefinitionId) return;
        _dropTargetChore = chore;
    }

    private async Task HandleDrop(ChorePlannerRow targetChore)
    {
        if (!EnableReorder || _draggedChore == null || _draggedChore.ChoreDefinitionId == targetChore.ChoreDefinitionId)
        {
            HandleDragEnd();
            return;
        }

        // Calculate new sort orders
        var updates = CalculateNewSortOrders(_draggedChore, targetChore);
        
        HandleDragEnd();
        
        if (updates.Count > 0)
        {
            await OnReorder.InvokeAsync(updates);
        }
    }

    private List<(int ChoreId, int SortOrder)> CalculateNewSortOrders(ChorePlannerRow draggedChore, ChorePlannerRow targetChore)
    {
        var updates = new List<(int ChoreId, int SortOrder)>();
        
        var choreList = RoutineChores.ToList();
        var draggedIndex = choreList.FindIndex(c => c.ChoreDefinitionId == draggedChore.ChoreDefinitionId);
        var targetIndex = choreList.FindIndex(c => c.ChoreDefinitionId == targetChore.ChoreDefinitionId);
        
        if (draggedIndex == -1 || targetIndex == -1 || draggedIndex == targetIndex)
            return updates;

        // Remove from old position and insert at new position
        choreList.RemoveAt(draggedIndex);
        choreList.Insert(targetIndex, draggedChore);

        // Assign new sort orders (multiply by 10 to leave gaps for future insertions)
        for (int i = 0; i < choreList.Count; i++)
        {
            var newSortOrder = (i + 1) * 10;
            updates.Add((choreList[i].ChoreDefinitionId, newSortOrder));
        }

        return updates;
    }
}
