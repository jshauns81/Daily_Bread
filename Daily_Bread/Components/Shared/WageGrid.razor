@using Daily_Bread.Data.Models
@using Daily_Bread.Services

<!-- Wage Grid -->
<div class="wage-grid">
    <!-- Day Headers -->
    <div class="grid-header">
        @if (EnableReorder)
        {
            <div class="header-cell drag-header"></div>
        }
        <div class="header-cell job-header">Job</div>
        @foreach (var day in PlannerData.DayColumns)
        {
            <div class="header-cell day-header @(day.IsToday ? "today" : "") @(day.IsPast ? "past" : "")">
                <span class="day-name">@day.DayName</span>
                <span class="day-num">@day.DayNumber</span>
            </div>
        }
        <div class="header-cell wage-header">Wage</div>
    </div>

    <!-- Chore Rows -->
    @foreach (var chore in EarningChores)
    {
        var isBeingDragged = _draggedChore?.ChoreDefinitionId == chore.ChoreDefinitionId;
        var isDropTarget = _dropTargetChore?.ChoreDefinitionId == chore.ChoreDefinitionId && !isBeingDragged;
        
        <div class="chore-row @(isBeingDragged ? "dragging" : "") @(isDropTarget ? "drop-target" : "")" 
             @key="chore.ChoreDefinitionId"
             draggable="@(EnableReorder ? "true" : "false")"
             @ondragstart="() => HandleDragStart(chore)"
             @ondragend="HandleDragEnd"
             @ondragover="() => HandleDragOver(chore)"
             @ondragover:preventDefault="@EnableReorder"
             @ondrop="() => HandleDrop(chore)"
             @ondrop:preventDefault="@EnableReorder">
            @if (EnableReorder)
            {
                <div class="drag-handle-cell">
                    <span class="drag-handle" title="Drag to reorder">
                        <span class="bi bi-grip-vertical"></span>
                    </span>
                </div>
            }
            <!-- Job Info -->
            <div class="job-cell" @onclick="() => OnEditChore.InvokeAsync(chore)">
                <span class="job-emoji">@(chore.Icon ?? "✨")</span>
                <div class="job-details">
                    <span class="job-name">@chore.ChoreName</span>
                    @if (chore.ScheduleType == ChoreScheduleType.WeeklyFrequency)
                    {
                        <span class="job-meta weekly">@chore.WeeklyApprovedCount/@chore.WeeklyTargetCount this week</span>
                    }
                    else if (!chore.IsDailyChore)
                    {
                        <span class="job-meta">@chore.ScheduleDescription</span>
                    }
                    @if (string.IsNullOrEmpty(SelectedUserId) && !string.IsNullOrEmpty(chore.AssignedUserName))
                    {
                        <span class="job-assignee">@chore.AssignedUserName</span>
                    }
                </div>
            </div>

            <!-- Day Cells -->
            @foreach (var cell in chore.Cells)
            {
                var cellKey = $"{chore.ChoreDefinitionId}_{cell.Date:yyyyMMdd}";
                var isUpdating = UpdatingCellKey == cellKey;

                <div class="day-cell @GetCellClasses(cell)"
                     @onclick="() => OnCellClick.InvokeAsync((chore, cell))"
                     title="@GetCellTooltip(chore, cell)"
                     @key="cellKey">
                    @if (isUpdating)
                    {
                        <span class="cell-spinner"></span>
                    }
                    else
                    {
                        <span class="cell-indicator">
                            @if (cell.IsScheduled)
                            {
                                @if (cell.HasOverride)
                                {
                                    <span class="indicator override">⚡</span>
                                }
                                else
                                {
                                    <span class="indicator scheduled">@(chore.Icon ?? "●")</span>
                                }
                            }
                            else if (cell.Status == ChoreCellStatus.Available)
                            {
                                <span class="indicator available">○</span>
                            }
                            else if (cell.HasOverride && cell.OverrideType == ScheduleOverrideType.Remove)
                            {
                                <span class="indicator removed">✕</span>
                            }
                            else
                            {
                                <span class="indicator empty"></span>
                            }
                        </span>
                    }
                </div>
            }

            <!-- Wage -->
            <div class="wage-cell">
                <span class="wage-amount">$@chore.Value.ToString("F2")</span>
                @if (chore.ScheduleType == ChoreScheduleType.WeeklyFrequency && chore.WeeklyTargetCount > 1)
                {
                    <span class="wage-multiplier">×@chore.WeeklyTargetCount</span>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired] public ChorePlannerData PlannerData { get; set; } = default!;
    [Parameter, EditorRequired] public List<ChorePlannerRow> EarningChores { get; set; } = [];
    [Parameter] public string? SelectedUserId { get; set; }
    [Parameter] public string? UpdatingCellKey { get; set; }
    [Parameter] public EventCallback<ChorePlannerRow> OnEditChore { get; set; }
    [Parameter] public EventCallback<(ChorePlannerRow Chore, ChorePlannerCell Cell)> OnCellClick { get; set; }
    
    /// <summary>
    /// Enable drag-and-drop reordering. When true, shows drag handles.
    /// </summary>
    [Parameter] public bool EnableReorder { get; set; } = true;
    
    /// <summary>
    /// Called when chores are reordered via drag-and-drop.
    /// Returns list of (ChoreId, NewSortOrder) tuples.
    /// </summary>
    [Parameter] public EventCallback<List<(int ChoreId, int SortOrder)>> OnReorder { get; set; }

    private ChorePlannerRow? _draggedChore;
    private ChorePlannerRow? _dropTargetChore;

    private string GetCellClasses(ChorePlannerCell cell)
    {
        var classes = new List<string>();
        if (cell.IsToday) classes.Add("today");
        if (cell.IsPast) classes.Add("past");
        if (cell.HasOverride) classes.Add("override");
        if (cell.IsScheduled) classes.Add("scheduled");
        else if (cell.Status == ChoreCellStatus.Available) classes.Add("available");
        else classes.Add("empty");
        return string.Join(" ", classes);
    }

    private string GetCellTooltip(ChorePlannerRow chore, ChorePlannerCell cell)
    {
        var action = cell.IsScheduled ? "Remove from" : "Add to";
        return $"{cell.Date:dddd, MMM d} — Click to {action.ToLower()} this day";
    }

    private void HandleDragStart(ChorePlannerRow chore)
    {
        if (!EnableReorder) return;
        _draggedChore = chore;
    }

    private void HandleDragEnd()
    {
        _draggedChore = null;
        _dropTargetChore = null;
    }

    private void HandleDragOver(ChorePlannerRow chore)
    {
        if (!EnableReorder || _draggedChore == null || _draggedChore.ChoreDefinitionId == chore.ChoreDefinitionId) return;
        _dropTargetChore = chore;
    }

    private async Task HandleDrop(ChorePlannerRow targetChore)
    {
        if (!EnableReorder || _draggedChore == null || _draggedChore.ChoreDefinitionId == targetChore.ChoreDefinitionId)
        {
            HandleDragEnd();
            return;
        }

        // Calculate new sort orders
        var updates = CalculateNewSortOrders(_draggedChore, targetChore);
        
        HandleDragEnd();
        
        if (updates.Count > 0)
        {
            await OnReorder.InvokeAsync(updates);
        }
    }

    private List<(int ChoreId, int SortOrder)> CalculateNewSortOrders(ChorePlannerRow draggedChore, ChorePlannerRow targetChore)
    {
        var updates = new List<(int ChoreId, int SortOrder)>();
        
        var choreList = EarningChores.ToList();
        var draggedIndex = choreList.FindIndex(c => c.ChoreDefinitionId == draggedChore.ChoreDefinitionId);
        var targetIndex = choreList.FindIndex(c => c.ChoreDefinitionId == targetChore.ChoreDefinitionId);
        
        if (draggedIndex == -1 || targetIndex == -1 || draggedIndex == targetIndex)
            return updates;

        // Remove from old position and insert at new position
        choreList.RemoveAt(draggedIndex);
        choreList.Insert(targetIndex, draggedChore);

        // Assign new sort orders (multiply by 10 to leave gaps for future insertions)
        for (int i = 0; i < choreList.Count; i++)
        {
            var newSortOrder = (i + 1) * 10;
            updates.Add((choreList[i].ChoreDefinitionId, newSortOrder));
        }

        return updates;
    }
}
